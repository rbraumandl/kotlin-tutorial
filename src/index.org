* Die Programmiersprache Kotlin

Die Programmiersprache Kotlin wurde von JetBrains im Jahre 2011 vorgestellt.
Die Hauptentwicklung findet in Sankt Petersburg statt und der Name Kotlin stammt
von einer Insel, die vor Sankt Petersburg liegt.

Die Entwickler von Kotlin hatten die Programmiersprache Scala
bezüglich den Programmiersprachen-Features im Blick, wobei Ihnen aber die
Geschwindigkeit des Scala Compilers zu gering und die Kompatibilität
zu Java nicht ausreichend genug waren. Kotlin ist daher keine kleine
Programmiersprache, da versucht wird, möglicht viele Features von Scala
zu realisieren, aber trotzdem kompatibler zu Java zu sein. Das führt zu
relativ vielen Kompromissen und geringerer Orthogonalität bei der Nutzung
von Programmiersprachenkonstrukten. 

Kotlin ist also eher in der Tradition der Programmiersprachen von
Anders Hejlberg (Turbo Pascal, Delphi, C#, Typescript) zu sehen, die
eher pragmatisch als theoretisch fundiert und minimalistisch
auftreten.

Wie schon von Java und vor allem Scala bekannt, ist Kotlin eine
objekt-orientierte Programmiersprache, die verschiedene Anleihen aus
den funktionalen Programmiersprachen nimmt.

* Zielsetzung

In diesem Tutorial werden wir daher definitiv nicht alle Details der
Sprache vorstellen, sondern versuchen neben dem notwendigen Grundstock
die Features zu vermitteln, die Kotlin auszeichnen und die
unterschiedlich zu Java sind. Wir werden uns auch nur das Java Backend
Einsatzszenario von Kotlin ansehen.

Die vollständige Definition der Progammiersprache ist auf der
Hauptseite der Programmiersprache zu finden:
[[https://kotlinlang.org/][Kotlin Hauptseite]]

* Erste Versuche auf der Kommandozeile

Das Paket mit dem Kommandozeilen Compiler ist ebenfalls vom
[[https://kotlinlang.org/docs/tutorials/command-line.html][Kotlin Webauftritt]] zu beziehen.

Wie auch Java seit Java 9 bietet auch Kotlin die Möglichkeit einfache
Programmkonstrukte in der Kotlin Shell auszuprobieren. 

Ein minimales und traditionsreiches, erstes Kotlin Programm sieht so
aus:
#+begin_src kotlin :exports none
fun main() {
    println("Hello world")
}
#+end_src
Im Gegensatz zu Java gibt es in Kotlin top-level Funktionen und die
Funktion ~main()~ als ein möglicher Einstiegspunkt eines jeden Kotlin
Programms ist eine solche Funktion. Diesen Code kann man auch einfach
in die Kotlin Shell kopieren und dann aufrufen.

#+begin_example
>>> fun main() {
...     println("Hello world")
... }
>>> main()
Hello world
#+end_example


Wenn wir diesen Code in der Datei HelloWorld.kt abspeichern und dann
den Compiler folgendermaßen aufrufen:
#+begin_src sh
> kotlinc HelloWorld.kt 
#+end_src
sehen wir, dass eine Java Class Datei und ein Meta-Inf Verzeichnis mit
der Datei main.kotlin.module erzeugt wurde:
#+begin_example
.:
HelloWorld.kt  HelloWorldKt.class  META-INF

./META-INF:
main.kotlin_module
#+end_example
Die Datei ~main.kotlin_module~ ist dabei ein Hilfskonstrukt, das dem
Kotlin Compiler hilft, Aufrufe von top-level Funktionen beim Linken
auszulösen. Wir müssen uns nicht weiter um diese Datei kümmern.

Ein Dekompilieren der Class Datei mit javap zeigt, dass aus
Kompatibilitätsgründen mit Java auch die klassische ~public static void
main(String[] args)~ Methode erzeugt worden ist. 
#+begin_example
> javap HelloWorldKt.class 

Compiled from "HelloWorld.kt"
public final class HelloWorldKt {
  public static final void main();
  public static void main(java.lang.String[]);
}
#+end_example
Diese ist wegen der Nutzung des Java Laufzeitsystem notwendig und wird
genutzt, um die Methode ~void main()~ aufzurufen, die für die
top-level ~main()~ Funktion erzeugt wurde. Aufgerufen wird das
Programm mit dem Java Interpreter und bei diesem Aufruf wird natürlich die
~void main(String[] args)~ Methode aufgerufen:
#+begin_src sh
java HelloWorldKt
#+end_src
Wir sehen im Aufruf und auch der dekompilierten Klasse, dass die
Klasse ~HelloWorldKt~ im Java ByteCode erzeugt wurde. Diese Klassen,
deren Namen sich ergeben aus dem Dateinamen und dem Suffix Kt werden
genutzt, um den Code der top-level Kotlin Funktionen aufzunehmen.

Es kann auch ganz klassisch die main Methode von Java in Kotlin
genutzt werden. 
#+begin_src kotlin :exports both

fun main(args: Array<String>) {
    println(args.contentToString())
}

main(arrayOf("Eins","Zwei"))
#+end_src

#+RESULTS:
: [Eins, Zwei]
: res7: kotlin.String = >>> 

Wenn man jetzt versucht, eine Kotlin Datei mit der klassischen main
Methode zu kompilieren und per Java Interpreter auszuführen, wird man
eine Fehlermeldung erhalten, obwohl das Beispiel in der Kotlin Shell funktioniert:
#+begin_example
> java HelloWorldKt
Exception in thread "main" java.lang.NoClassDefFoundError: kotlin/jvm/internal/Intrinsics
	at HelloWorldKt.main(HelloWorld.kt)
Caused by: java.lang.ClassNotFoundException: kotlin.jvm.internal.Intrinsics
	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:581)
	at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522)
	... 1 more

#+end_example
Grund dafür ist, dass Kotlin eine eigene Laufzeitbibliothek besitzt,
die wir im Programm durch die Nutzung der ~Array~ Klasse referenzieren,
aber das Java Laufzeitsystem diese Bibliothek im Normalfall nicht
kennt. Ein einfacher Weg das Problem zu umgehen, ist die Nutzung des
Programms kotlin, das im Kommandozeilen Paket von Kotlin enthalten ist
und die Einbindung des Laufzeitsystems übernimmt:
#+begin_example
> kotlin HelloWorldKt
[]
#+end_example
Eine andere Alternative für stand-alone Programme ist, das bauen einer
Jar Datei, die das Laufzeitsystem von Kotlin enthält:
#+begin_example
> kotlinc -include-runtime HelloWorld.kt -d HelloWorld.jar
> java -jar HelloWorld.jar 
[]
#+end_example
