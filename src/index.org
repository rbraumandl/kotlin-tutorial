#+TITLE:     Kotlin Tutorial
#+AUTHOR:    Reinhard Braumandl
#+DESCRIPTION: Ein kleines Tutorial zur Programmiersprache Kotlin
#+KEYWORDS:  kotlin, tutorial
#+LANGUAGE:  de
#+OPTIONS:   toc:2
#+OPTIONS: H:4
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-bigblow.setup

* Die Programmiersprache Kotlin

Die Programmiersprache Kotlin wurde von JetBrains im Jahre 2011 vorgestellt.
Die Hauptentwicklung findet in Sankt Petersburg statt und der Name Kotlin stammt
von einer Insel, die vor Sankt Petersburg liegt.

Die Entwickler von Kotlin hatten die Programmiersprache Scala
bezüglich den Programmiersprachen-Features im Blick, wobei Ihnen aber die
Geschwindigkeit des Scala Compilers zu gering und die Kompatibilität
zu Java nicht ausreichend genug waren. Kotlin ist daher keine kleine
Programmiersprache, da versucht wird, möglicht viele Features von Scala
zu realisieren, aber trotzdem kompatibler zu Java zu sein. Das führt zu
relativ vielen Kompromissen und geringerer Orthogonalität bei der Nutzung
von Programmiersprachenkonstrukten. 

Kotlin ist also eher in der Tradition einer Reihe von aktuellen
Programmiersprachen zu sehen, die eher pragmatisch als theoretisch
fundiert und minimalistisch auftreten. Kehrseite der Medaille ist dann
meist, dass die von diesen Programmiersprachen unterstützten
Konstrukte im Laufe der Enwicklung immer weiter ausufern.

Wie schon von neueren Versionen von Java und vor allem Scala bekannt,
ist Kotlin eine objekt-orientierte Programmiersprache, die
verschiedene Anleihen aus den funktionalen Programmiersprachen nimmt.

Besondere Ziele bei der Entwicklung von Kotlin sind:
- Boilerplate Code soll vermieden werden (z.B. mittels Data Classes,
  Default Parameter, Extension Functions, Überladen von Operatoren,
  Typ Inferenz)
- Vermeidung von NullPointerExceptions durch Prüfungen zur
  Compile-Zeit (Null Safety)
- Integration von Konzepten funktionaler Programmiersprachen (Higher
  Order Functions, Pattern Matching, Tail Call Optimization)
- Kompatibilität mit Java


* Zielsetzung

In diesem Tutorial werden wir definitiv nicht alle Details der Sprache
Kotlin vorstellen, sondern versuchen neben dem notwendigen Grundstock
die Features zu vermitteln, die Kotlin auszeichnen und die
unterschiedlich zu Java sind. Wir werden uns auch nur das Java Backend
Einsatzszenario von Kotlin ansehen.

Die Beschreibung der Progammiersprache Kotlin ist auf deren Hauptseite
im Web zu finden: [[https://kotlinlang.org/][Kotlin Hauptseite]] 

Die relativ formale [[https://kotlinlang.org/spec/introduction.html][Definition der Sprache]] gibt im Vergleich zum
größten Teil dieses Webauftritts die präzisere Definition der Sprache
wieder. Bei Zweifeln über bestimmte Konstrukte sollte also die
Sprachdefinition zu Rate gezogen werden.

* Erste Versuche auf der Kommandozeile

Wir starten das Kennenlernen mit der Programmiersprache Kotlin auf
Kommandozeilenebene und nicht gleich in der für Kotlin prädestinierten
IDE IntelliJ. Hierdurch bekommt man eher ein Gefühlt dafür, wie die
Integration mit der Java Plattform realisiert ist - das zumindest ist
unsere Meinung.

Wir nutzen dabei im folgenden eine Linux Installation, um die
Beispiele durchzuspielen. In den Beispielen zeigt der Prompt ~>~ den
Bash Prompt (Linux Shell) an und ~>>>~ den Prompt der Kotlin Shell.

Hierzu müssen wir auf dem Computer des Lesers zunächst das separat
erhältliche Paket mit den Kotlin Kommandozeilen Tools installieren.
Das Paket mit dem Kommandozeilen Compiler ist vom [[https://kotlinlang.org/docs/tutorials/command-line.html][Kotlin Webauftritt]]
zu beziehen, wobei auch eine Anleitung für die Installation gegeben
ist. Das Prozedere der Installation sei als dem Leser überlassen.

Wie auch Java seit Version 9 bietet auch Kotlin die Möglichkeit
Programmkonstrukte in der Kotlin Shell auszuprobieren. Der Aufruf der
Kotlin Shell erfolgt einfach 

Ein minimales und traditionsreiches, erstes Kotlin Programm sieht so
aus:
#+begin_src kotlin :exports none
fun main() {
    println("Hello world")
}
#+end_src
Im Gegensatz zu Java gibt es in Kotlin top-level Funktionen und die
Funktion ~main()~ als ein möglicher Einstiegspunkt eines Kotlin
Programms ist eine solche Funktion. Diesen Code kann man auch einfach
in die Kotlin Shell kopieren und dann aufrufen.

#+begin_example
>>> fun main() {
...     println("Hello world")
... }
>>> main()
Hello world
#+end_example


Wenn wir diesen Code in der Datei HelloWorld.kt abspeichern und dann
den Compiler folgendermaßen aufrufen:
#+begin_src sh
> kotlinc HelloWorld.kt 
#+end_src
sehen wir, dass eine Java Class Datei und ein Meta-Inf Verzeichnis mit
der Datei main.kotlin.module erzeugt wurde:
#+begin_example
.:
HelloWorld.kt  HelloWorldKt.class  META-INF

./META-INF:
main.kotlin_module
#+end_example
Die Datei ~main.kotlin_module~ ist dabei ein Hilfskonstrukt, das dem
Kotlin Compiler hilft, Aufrufe von top-level Funktionen beim Linken
auszulösen. Wir müssen uns nicht weiter um diese Datei kümmern.

Ein Dekompilieren der Class Datei mit javap zeigt, dass aus
Kompatibilitätsgründen mit Java auch die klassische ~public static void
main(String[] args)~ Methode erzeugt worden ist. 
#+begin_example
> javap HelloWorldKt.class 

Compiled from "HelloWorld.kt"
public final class HelloWorldKt {
  public static final void main();
  public static void main(java.lang.String[]);
}
#+end_example
Diese ist wegen der Nutzung des Java Laufzeitsystem notwendig und wird
genutzt, um die Methode ~void main()~ aufzurufen, die für die
top-level ~main()~ Funktion erzeugt wurde. Aufgerufen wird das
Programm mit dem Java Interpreter und bei diesem Aufruf wird natürlich die
~void main(String[] args)~ Methode aufgerufen:
#+begin_src sh
java HelloWorldKt
#+end_src
Wir sehen im Aufruf und auch der dekompilierten Klasse, dass die
Klasse ~HelloWorldKt~ im Java ByteCode erzeugt wurde. Diese Klassen,
deren Namen sich ergeben aus dem Dateinamen und dem Suffix Kt werden
genutzt, um den Code der top-level Kotlin Funktionen aufzunehmen.

Es kann auch ganz klassisch die main Methode von Java in Kotlin
genutzt werden. 
#+begin_src kotlin :exports both

fun main(args: Array<String>) {
    println(args.contentToString())
}

main(arrayOf("Eins","Zwei"))
#+end_src

#+RESULTS:
: [Eins, Zwei]
: res7: kotlin.String = >>> 

Wenn man jetzt versucht, eine Kotlin Datei mit der klassischen main
Methode zu kompilieren und per Java Interpreter auszuführen, wird man
eine Fehlermeldung erhalten, obwohl das Beispiel in der Kotlin Shell funktioniert:
#+begin_example
> java HelloWorldKt
Exception in thread "main" java.lang.NoClassDefFoundError: kotlin/jvm/internal/Intrinsics
	at HelloWorldKt.main(HelloWorld.kt)
Caused by: java.lang.ClassNotFoundException: kotlin.jvm.internal.Intrinsics
	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:581)
	at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522)
	... 1 more

#+end_example
Grund dafür ist, dass Kotlin eine eigene Laufzeitbibliothek besitzt,
die wir im Programm durch die Nutzung der ~Array~ Klasse referenzieren,
aber das Java Laufzeitsystem diese Bibliothek im Normalfall nicht
kennt. Ein einfacher Weg das Problem zu umgehen, ist die Nutzung des
Programms kotlin, das im Kommandozeilen Paket von Kotlin enthalten ist
und die Einbindung des Laufzeitsystems übernimmt:
#+begin_example
> kotlin HelloWorldKt Eins Zwei
[Eins, Zwei]
#+end_example
Es kann natürlich auch der Java Interpreter genutzt werden, wenn man
die passende Bibliothek aus dem Kotlin Paket mit einbindet:
#+begin_example
> java -classpath ~/programme/kotlinc/lib/kotlin-stdlib.jar:. HelloWorldKt Eins Zwei
[Eins, Zwei]
#+end_example

Eine andere Alternative für stand-alone Programme ist, das Bauen einer
Jar Datei, die das Laufzeitsystem von Kotlin enthält:
#+begin_example
> kotlinc -include-runtime HelloWorld.kt -d HelloWorld.jar
> java -jar HelloWorld.jar Eins Zwei
[Eins, Zwei]
#+end_example
An der Größe der Jar Datei von etwa 1,5 MByte erkennt man gleich, dass
hier etwas mehr Code als der aus dem Beispiel mit abgelegt wurde. Es
sollte klar sein, dass die ~-include-runtime~ Option nicht bei der
Erstellung von Bibliotheken genutzt werden sollte, da die Runtime von
Kotlin jeweils nur im Code von lauffähigen Programmen benötigt wird
und wie oben gezeigt auch über die Referenz der passenden Runtime
Bibliothek eingebunden werden kann.

* Elementare Datentypen und Ausdrücke

Bevor wir komplexere Konstrukte von Kotlin ansehen, müssen wir einige
Grundzüge der Programmiersprache betrachten. 

** Lokale Variablen

Wir betrachten hier nur lokale Variablen in Code Blöcken wie z.B.
in Funktionen. Sogenannte Properties die analog definiert werden und
auf top-level Ebene und in Klassen verwendet werden können, haben
erweiterte Möglichkeiten und werden später betrachtet.

Das Schlüsselwort ~var~ leitet eine Variablendeklaration ein. Wie man
es erwartet ist der Wert einer solchen Variable änderbar. In den
folgenden Beispielen verwenden wir den Typ ~Int~, der erwartungsgemäß
Integer Zahlen repräsentiert.
#+begin_src kotlin :exports both
fun main() {
  var a: Int = 1    // Deklaration mit Typangabe und Initialisierung
  var b = 2         // Typ Inferenz 
  var c: Int        // Deklaration ohne Initialisierung
  c = 3             // spätere Initialisierung
  println("a = ${a}, b = ${b}, c = ${c}") 
  a++
  b++
  c++
  println("a = ${a}, b = ${b}, c = ${c}")
}

main()
#+end_src

#+RESULTS:
: a = 1, b = 2, c = 3
: a = 2, b = 3, c = 4

Zunächst muss man festhalten, dass in Kotlin die Typen mit einem
Doppelpunkt abgetrennt nach den Bezeichnern stehen. Das gilt dann auch
für Rückgabewerte von Funktionen, wie wir später sehen werden.

Wir sehen zu Beginn der ~main~ Funktion die gleichzeitige Deklaration
und Zuweisung der Variablen ~a~, die Deklaration und Initialisierung
der Variablen ~b~ ohne Typangabe und die Deklaration der mit Typangabe
der Variable ~c~ mit späterer Initialierung der Variablen. 

Bei der Variablen ~b~ wurde der Typ ~Int~ per Typ Inferenz von Kotlin
selber bestimmt, ohne dass der Programmierer dies angeben musste. 

Anhand der Nutzung der top-level Funktion ~println~ können wir auch
sehen, dass in Kotlin Strings standardmäßig Variablen Interpolation
erlauben.

Das Schlüsselwort ~val~ leitet eine einmal beschreibbare Variable
ein. Also eher vergleichbar mit einer Konstanten. Es gibt auch noch
das Schlüsselwort ~const~, das im Zusammenspiel mit einer ~val~
Variablen eingesetzt werden kann und eine sofortige Zuweisung
erzwingt, worauf wir aber nicht weiter eingehen, da ~const~ recht
inkonsistent nur an wenigen Stellen verwendet werden kann.

#+begin_src kotlin :exports both
fun main() {
  val a: Int = 1
  val b = 2
  val c: Int      // Initialisierung kann auch bei val verzögert sein
  c = 3
  
  println("a = ${a}, b = ${b}, c = ${c}")
  // c = 4           nicht erlaubt, Compiler meldet Fehler!!
}

main()
#+end_src

#+RESULTS:
: a = 1, b = 2, c = 3



** Elementare Datentypen

Anders als in Java werden in Kotlin nur Objekttypen verwendet, auch
für alle elementaren Datentypen. Als Konsequenz sind alle Operationen
auf den Datentypen per Member-Funktion erreichbar, wobei die
Operationen größtenteils den aus Java bekannten gleichen.

Intern verwendet Kotlin aus Performancegründen teilweise die
primitiven Datentypen der Java VM, aber dies ist weitestgehend
unsichtbar für den Programmierer.


*** Ganzzahlige Datentypen

Es gibt die von Java bekannten vorzeichenbehafteten Typen (signed integers)
- Byte (8 Bit)
- Short (16 Bit)
- Int (32 Bit)
- Long (64 Bit)

#+begin_note
In den neueren Version von Kotlin ist experimenteller Support für
unsigned integers integriert.
#+end_note

#+begin_src kotlin :exports both
val byte: Byte = 1 
val short: Short = 128
val int: Int = 32768
val long: Long = 2147483647
val int1 = 10 // Int als default hergeleiteter Typ
val long1 = 2147483647 // long, da Wertebereich Int überschreitet
val long2 = 8L // per L Suffix wird Long als Typ erzwungen

long2.toString(2) // Zahlen sind Objekte, 8 wird als Zahl zur Basis 2 ausgegeben
#+end_src

#+RESULTS:
: kotlin.String = 1000

*** Gleitkommazahlen Datentypen

Analog zum vorherigen Abschnitt gibt es auch bei den Gleitkommazahlen
die beiden von Java bekannten Typen ~Float~ und ~Double~.

#+begin_src kotlin :exports both
val double : Double = 0.8
val pi = 3.14
val pif = 6.28f // Suffix f führt zu Float Type anstatt zum default von Double
println("${pi.hashCode()} ${pif.hashCode()}")
#+end_src

#+RESULTS:
: 300063655 1086911939

*** Booleans

Auch hier gibt es keine großen Überraschungen.

#+begin_src kotlin exports: both
val myTrue: Boolean = true
val myFalse: Boolean = false

println(myTrue || myFalse)
#+end_src

#+RESULTS:
: true

*** Zeichen/Characters

Hier gibt es ebenfalls keine Überraschungen im Vergleich zu Java.

#+begin_src kotlin export: both
val charA: Char = 'a'
val charSpecial = '\n'
val charB: Char = 'b'
println("${charA} ${charSpecial} ${charB}")
#+end_src

#+RESULTS:
: a 
:  b

*** Zeichenketten/Strings

Strings sind wiederum sehr ähnlich zu Java aufgebaut. Es gibt
zusätzlich zu den normalen Strings auch die sogenannten Raw Strings,
die mehrzeilig sein können und keine Escape Sequenzen umsetzen.
#+begin_note
Die in Java 13 eingeführten Raw Strings unterscheiden sich relativ
stark der Kotlin Variante: Interpretatio von Escape Sequenzen und
automatische Behandlung von Einrückungen.
#+end_note

#+begin_src kotlin :exports both
val rawString = """
    \n\n\t
    
    ein Test
""".trimIndent()

println(rawString)

println("\n\n")

val withoutMargin1 = """ABC
                |123
                |456""".trimMargin()

println(withoutMargin1)
#+end_src

#+RESULTS:
: \n\n\t
: 
: ein Test
: 
: 
: 
: ABC
: 123
: 456

Die Funktionen ~trimIndent()~ und ~trimMargin()~ entfernen die
Einrückungen der inneren Zeilen samt Löschen der ersten und letzten
Zeile.

In normalen wie auch in Raw Strings wird String Interpolation
unterstützt.
#+begin_src kotlin :exports both
val s = "2 + 3 = ${2+3}"
println(s)
val sr = """
2${'$'} + 3${'$'} = ${2+3}${'$'}

4${'$'} + 5${'$'} = ${4+5}${'$'}
"""
println(sr)
#+end_src

#+RESULTS:
: 2 + 3 = 5
: 
: 2$ + 3$ = 5$
: 
: 4$ + 5$ = 9$

*** Arrays


** Ausdrücke und Anweisungen

Da Kotlin sich viele Anleihen aus dem Bereich der funktionalen
Programmierung genommen, sind anders als in Java angepasste Varianten
von Anweisungen auch in Form von Ausdrücken verwendbar.

#+begin_note
Anmerkung: Ausdrücke liefern Werte - Anweisungen nicht, sie
ändern nur den Kontrollfluss.
#+end_note

* Grundkonstruktion von Programmen

** Kein static Modifier und die Folgen
Kotlin unterstützt auf Sprachenebene nicht den Modifier ~static~, der
in Java zur Zuordnung von Variablen und Methoden zu Klassen genutzt
werden kann. Dies hat für einige Konstrukte in Kotlin gesorgt, um
Funktionalitäten nachzubilden, für die in Java ~static~ verwendet
wurde. Die Details dieser Konstrukte sehen wir uns später an.

- Statt static Member Variablen gibt es top-level Properties.
- Statt static Methoden gibt es top-level Funktionsdefinitionen.
- Für Singletons gibt es die Möglichkeit top-level Quasi-Klassen zu
  definieren, von denen genau ein Objekt existiert. Dieses Konstrukt
  wird auch einfach Object genannt.
- Um Objekten einer Klasse die Möglichkeit zu geben, um auf
  Klassenebene Strukturen und Funktionen zu nutzen, gibt es das
  Konstrukt ~companion object~, das in einer Klasse definiert sein
  kann. Darüber kann man zum Beispiel ein Factory Method Pattern
  abbilden. Ein ~companion object~ ist also eine Art Singleton, das
  explizit einer Klasse zugeordnet ist.

** Top Level Konstrukte der Programmiersprache


*** Funktionen

Die Parameter einer Funktion müssen explizit angegebene Typen haben.

*** Properties	



*** Interfaces

*** Klassen

**** Properties in Klassen
Properties in Klassen sind analog zu definieren wie top-level Properties.

#+begin_src kotlin :exports both
class Test {
  var test : String = "Variabler Wert"
  val rtest = "ReadOnly Wert mit type inference"
}

val t = Test()
t.test + " " + t.rtest
#+end_src

Properties in Klassen können analog zu top-level Properties ihre
default-Getter und -Setter überschreiben:
#+begin_src kotlin :exports both
class Test {
  var test : Int = 2
  get() = field + 1 // Nutzung des backing field
  set(value) {
    field += value
  }
}
val t = Test()
t.test = 2 // impliziter Call des Setter
t.test     // impliziter Call des Getter
#+end_src


#+RESULTS:
: kotlin.Int = 5

Man kann auch die Sichtbarkeit der Getter und Setter steuern:
#+begin_src kotlin :exports both
class Test {
  var test : Int = 2
  get() = field + 1 // Nutzung des backing field
  private set // auch ohne Implementierung nur für die Sichtbarkeit
}
val t = Test()
//t.test = 2 würde jetzt einen Fehler ergeben
t.test     // impliziter Call des Getter
#+end_src

#+RESULTS:
: kotlin.Int = 3


**** Konstruktoren

Über den sogenannten primary constructor kann man Klassen schön
kompakt formulieren:
#+begin_src kotlin :exports both
class Test (var test : Int) { // Konstruktor Parameter und Property gleichzeitig definiert
}
val t = Test(2)
t.test
#+end_src

#+RESULTS:
: kotlin.Int = 2

Dieses Beispiel maximal länglich aber mit primary constructor wäre so zu formulieren:
#+begin_src kotlin :exports both
class Test constructor(testparam : Int) {
  var test : Int = testparam
}
val t = Test(2)
t.test
#+end_src

#+RESULTS:
: kotlin.Int = 2

Ein secondary constructor muss den primary constructor immer aufrufen,
damit der primary constructor bei Objektinitialisierung immer zuerst
ausgeführt wird. Dies muss vor allen wegen initializer Blocks und
Property Wertzuweisung passieren:
#+begin_src kotlin :exports both
class Test constructor(testparam : Int) {
  var test : Int = testparam
  var secTest : Int = 4

  constructor (testparam: Int, secparam : Int) : this(testparam) {
    secTest = secparam
  }
}
val t = Test(4,4)
t.test + t.secTest
#+end_src

#+RESULTS:
: kotlin.Int = 8

Falls kein primary constructor definiert wird, erzeugt Kotlin einen
default primary constructor, welcher auch automatisch bei Aufruf eines
secondary constructors ausgeführt wird:
#+begin_src kotlin :exports both
class Test {
  var test : Int
  init {
    test = 8
  }
  constructor (testparam : Int) {
    test += testparam
  }
}
val t = Test(2)
t.test
#+end_src

#+RESULTS:
: kotlin.Int = 10

** Organisation von Source Code

In diesem Abschnitt beschäftigen wir uns mit der Frage, wie man die
zuvor erwähnten top-level Sprachkonstrukte organisiert, um eine
strukturierte Programmentwicklung zu ermöglichen.

*** Modularisierung

Bisher haben wir in den Beispielen keine Konstrukte zur
Modularisierung von Code verwendet. Kotlin hat hierbei diese
Möglichkeiten:
- Package
- Module 

Modules spielen eine Rolle bei der Sichtbarkeit von ~internal~
Deklarationen und ansonsten bei einigen Backends für den Kotlin
Code. Wir werden dieses Konstrukt daher nicht weiter betrachten.


*** Aufbau einer Source Code Datei

*** Organisation der Dateiablage

*** Sichtbarkeitsregeln


