<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="de" xml:lang="de">
<head>
<!-- 2021-04-18 So 16:25 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Kotlin Tutorial</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Reinhard Braumandl" />
<meta name="description" content="Ein kleines Tutorial zur Programmiersprache Kotlin"
 />
<meta name="keywords" content="kotlin, tutorial" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/bigblow_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/bigblow_theme/css/bigblow.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/bigblow_theme/css/hideshow.css"/>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery-1.11.0.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery-ui-1.10.2.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery.localscroll-min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery.scrollTo-1.4.3.1-min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery.zclip.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/bigblow.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/hideshow.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Kotlin Tutorial</h1>
<div id="table-of-contents">
<h2>Inhaltsverzeichnis</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org67265db">Die Programmiersprache Kotlin</a></li>
<li><a href="#org11468a8">Zielsetzung</a></li>
<li><a href="#orgbf8e71c">Erste Versuche auf der Kommandozeile</a></li>
<li><a href="#org77668d4">Elementare Datentypen und Ausdrücke</a>
<ul>
<li><a href="#orged91158">Lokale Variablen</a></li>
<li><a href="#org5988f0d">Elementare Datentypen</a></li>
<li><a href="#orgde02234">Ausdrücke und Anweisungen</a></li>
</ul>
</li>
<li><a href="#org77d0243">Grundkonstruktion von Programmen</a>
<ul>
<li><a href="#orgfd21f64">Kein static Modifier und die Folgen</a></li>
<li><a href="#org464f89f">Top Level Konstrukte der Programmiersprache</a></li>
<li><a href="#org7d00225">Organisation von Source Code</a></li>
</ul>
</li>
<li><a href="#orgeca5528">Erstellen einer Domain Specific Language</a></li>
</ul>
</div>
</div>

<div id="outline-container-org67265db" class="outline-2">
<h2 id="org67265db">Die Programmiersprache Kotlin</h2>
<div class="outline-text-2" id="text-org67265db">
<p>
Die Programmiersprache Kotlin wurde von JetBrains im Jahre 2011 vorgestellt.
Die Hauptentwicklung findet in Sankt Petersburg statt und der Name Kotlin stammt
von einer Insel, die vor Sankt Petersburg liegt.
</p>

<p>
Die Entwickler von Kotlin hatten die Programmiersprache Scala
bezüglich den Programmiersprachen-Features im Blick, wobei Ihnen aber die
Geschwindigkeit des Scala Compilers zu gering und die Kompatibilität
zu Java nicht ausreichend genug waren. Kotlin ist daher keine kleine
Programmiersprache, da versucht wird, möglicht viele Features von Scala
zu realisieren, aber trotzdem kompatibler zu Java zu sein. Das führt zu
relativ vielen Kompromissen und geringerer Orthogonalität bei der Nutzung
von Programmiersprachenkonstrukten. 
</p>

<p>
Kotlin ist also eher in der Tradition einer Reihe von aktuellen
Programmiersprachen zu sehen, die eher pragmatisch als theoretisch
fundiert und minimalistisch auftreten. Kehrseite der Medaille ist dann
meist, dass die von diesen Programmiersprachen unterstützten
Konstrukte im Laufe der Enwicklung immer weiter ausufern.
</p>

<p>
Wie schon von neueren Versionen von Java und vor allem Scala bekannt,
ist Kotlin eine objekt-orientierte Programmiersprache, die
verschiedene Anleihen aus den funktionalen Programmiersprachen nimmt.
</p>

<p>
Besondere Ziele bei der Entwicklung von Kotlin sind:
</p>
<ul class="org-ul">
<li>Boilerplate Code soll vermieden werden (z.B. mittels Data Classes,
Default Parameter, Extension Functions, Überladen von Operatoren,
Typ Inferenz)</li>
<li>Vermeidung von NullPointerExceptions durch Prüfungen zur
Compile-Zeit (Null Safety)</li>
<li>Integration von Konzepten funktionaler Programmiersprachen (Higher
Order Functions, Pattern Matching, Tail Call Optimization)</li>
<li>Kompatibilität mit Java</li>
</ul>
</div>
</div>


<div id="outline-container-org11468a8" class="outline-2">
<h2 id="org11468a8">Zielsetzung</h2>
<div class="outline-text-2" id="text-org11468a8">
<p>
In diesem Tutorial werden wir definitiv nicht alle Details der Sprache
Kotlin vorstellen, sondern versuchen neben dem notwendigen Grundstock
die Features zu vermitteln, die Kotlin auszeichnen und die
unterschiedlich zu Java sind. Wir werden uns auch nur das Java Backend
Einsatzszenario von Kotlin ansehen.
</p>

<p>
Die Beschreibung der Progammiersprache Kotlin ist auf deren Hauptseite
im Web zu finden: <a href="https://kotlinlang.org/">Kotlin Hauptseite</a> 
</p>

<p>
Die relativ formale <a href="https://kotlinlang.org/spec/introduction.html">Definition der Sprache</a> gibt im Vergleich zum
größten Teil dieses Webauftritts die präzisere Definition der Sprache
wieder. Bei Zweifeln über bestimmte Konstrukte sollte also die
Sprachdefinition zu Rate gezogen werden.
</p>
</div>
</div>

<div id="outline-container-orgbf8e71c" class="outline-2">
<h2 id="orgbf8e71c">Erste Versuche auf der Kommandozeile</h2>
<div class="outline-text-2" id="text-orgbf8e71c">
<p>
Wir starten das Kennenlernen mit der Programmiersprache Kotlin auf
Kommandozeilenebene und nicht gleich in der für Kotlin prädestinierten
IDE IntelliJ. Hierdurch bekommt man eher ein Gefühlt dafür, wie die
Integration mit der Java Plattform realisiert ist - das zumindest ist
unsere Meinung.
</p>

<p>
Wir nutzen dabei im folgenden eine Linux Installation, um die
Beispiele durchzuspielen. In den Beispielen zeigt der Prompt <code>&gt;</code> den
Bash Prompt (Linux Shell) an und <code>&gt;&gt;&gt;</code> den Prompt der Kotlin Shell.
</p>

<p>
Hierzu müssen wir auf dem Computer des Lesers zunächst das separat
erhältliche Paket mit den Kotlin Kommandozeilen Tools installieren.
Das Paket mit dem Kommandozeilen Compiler ist vom <a href="https://kotlinlang.org/docs/tutorials/command-line.html">Kotlin Webauftritt</a>
zu beziehen, wobei auch eine Anleitung für die Installation gegeben
ist. Das Prozedere der Installation sei als dem Leser überlassen.
</p>

<p>
Wie auch Java seit Version 9 bietet auch Kotlin die Möglichkeit
Programmkonstrukte in der Kotlin Shell auszuprobieren. Der Aufruf der
Kotlin Shell erfolgt einfach 
</p>

<p>
Ein minimales und traditionsreiches, erstes Kotlin Programm sieht so
aus:
Im Gegensatz zu Java gibt es in Kotlin top-level Funktionen und die
Funktion <code>main()</code> als ein möglicher Einstiegspunkt eines Kotlin
Programms ist eine solche Funktion. Diesen Code kann man auch einfach
in die Kotlin Shell kopieren und dann aufrufen.
</p>

<pre class="example">
&gt;&gt;&gt; fun main() {
...     println("Hello world")
... }
&gt;&gt;&gt; main()
Hello world
</pre>


<p>
Wenn wir diesen Code in der Datei HelloWorld.kt abspeichern und dann
den Compiler folgendermaßen aufrufen:
</p>
<div class="org-src-container">
<pre class="src src-sh">&gt; kotlinc HelloWorld.kt 
</pre>
</div>
<p>
sehen wir, dass eine Java Class Datei und ein Meta-Inf Verzeichnis mit
der Datei main.kotlin.module erzeugt wurde:
</p>
<pre class="example">
.:
HelloWorld.kt  HelloWorldKt.class  META-INF

./META-INF:
main.kotlin_module
</pre>
<p>
Die Datei <code>main.kotlin_module</code> ist dabei ein Hilfskonstrukt, das dem
Kotlin Compiler hilft, Aufrufe von top-level Funktionen beim Linken
auszulösen. Wir müssen uns nicht weiter um diese Datei kümmern.
</p>

<p>
Ein Dekompilieren der Class Datei mit javap zeigt, dass aus
Kompatibilitätsgründen mit Java auch die klassische <code>public static void
main(String[] args)</code> Methode erzeugt worden ist. 
</p>
<pre class="example">
&gt; javap HelloWorldKt.class 

Compiled from "HelloWorld.kt"
public final class HelloWorldKt {
  public static final void main();
  public static void main(java.lang.String[]);
}
</pre>
<p>
Diese ist wegen der Nutzung des Java Laufzeitsystem notwendig und wird
genutzt, um die Methode <code>void main()</code> aufzurufen, die für die
top-level <code>main()</code> Funktion erzeugt wurde. Aufgerufen wird das
Programm mit dem Java Interpreter und bei diesem Aufruf wird natürlich die
<code>void main(String[] args)</code> Methode aufgerufen:
</p>
<div class="org-src-container">
<pre class="src src-sh">java HelloWorldKt
</pre>
</div>
<p>
Wir sehen im Aufruf und auch der dekompilierten Klasse, dass die
Klasse <code>HelloWorldKt</code> im Java ByteCode erzeugt wurde. Diese Klassen,
deren Namen sich ergeben aus dem Dateinamen und dem Suffix Kt werden
genutzt, um den Code der top-level Kotlin Funktionen aufzunehmen.
</p>

<p>
Es kann auch ganz klassisch die main Methode von Java in Kotlin
genutzt werden. 
</p>
<div class="org-src-container">
<pre class="src src-kotlin">
<span style="color: #a020f0;">fun</span> <span style="color: #0000ff;">main</span>(args: <span style="color: #228b22;">Array&lt;String&gt;</span>) {
    println(args.contentToString())
}

main(arrayOf(<span style="color: #8b2252;">"Eins"</span>,<span style="color: #8b2252;">"Zwei"</span>))
</pre>
</div>

<pre class="example">
[Eins, Zwei]
</pre>


<p>
Wenn man jetzt versucht, eine Kotlin Datei mit der klassischen main
Methode zu kompilieren und per Java Interpreter auszuführen, wird man
eine Fehlermeldung erhalten, obwohl das Beispiel in der Kotlin Shell funktioniert:
</p>
<pre class="example">
&gt; java HelloWorldKt
Exception in thread "main" java.lang.NoClassDefFoundError: kotlin/jvm/internal/Intrinsics
	at HelloWorldKt.main(HelloWorld.kt)
Caused by: java.lang.ClassNotFoundException: kotlin.jvm.internal.Intrinsics
	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:581)
	at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522)
	... 1 more

</pre>
<p>
Grund dafür ist, dass Kotlin eine eigene Laufzeitbibliothek besitzt,
die wir im Programm durch die Nutzung der <code>Array</code> Klasse referenzieren,
aber das Java Laufzeitsystem diese Bibliothek im Normalfall nicht
kennt. Ein einfacher Weg das Problem zu umgehen, ist die Nutzung des
Programms kotlin, das im Kommandozeilen Paket von Kotlin enthalten ist
und die Einbindung des Laufzeitsystems übernimmt:
</p>
<pre class="example">
&gt; kotlin HelloWorldKt Eins Zwei
[Eins, Zwei]
</pre>
<p>
Es kann natürlich auch der Java Interpreter genutzt werden, wenn man
die passende Bibliothek aus dem Kotlin Paket mit einbindet:
</p>
<pre class="example">
&gt; java -classpath ~/programme/kotlinc/lib/kotlin-stdlib.jar:. HelloWorldKt Eins Zwei
[Eins, Zwei]
</pre>

<p>
Eine andere Alternative für stand-alone Programme ist, das Bauen einer
Jar Datei, die das Laufzeitsystem von Kotlin enthält:
</p>
<pre class="example">
&gt; kotlinc -include-runtime HelloWorld.kt -d HelloWorld.jar
&gt; java -jar HelloWorld.jar Eins Zwei
[Eins, Zwei]
</pre>
<p>
An der Größe der Jar Datei von etwa 1,5 MByte erkennt man gleich, dass
hier etwas mehr Code als der aus dem Beispiel mit abgelegt wurde. Es
sollte klar sein, dass die <code>-include-runtime</code> Option nicht bei der
Erstellung von Bibliotheken genutzt werden sollte, da die Runtime von
Kotlin jeweils nur im Code von lauffähigen Programmen benötigt wird
und wie oben gezeigt auch über die Referenz der passenden Runtime
Bibliothek eingebunden werden kann.
</p>
</div>
</div>

<div id="outline-container-org77668d4" class="outline-2">
<h2 id="org77668d4">Elementare Datentypen und Ausdrücke</h2>
<div class="outline-text-2" id="text-org77668d4">
<p>
Bevor wir komplexere Konstrukte von Kotlin ansehen, müssen wir einige
Grundzüge der Programmiersprache betrachten. 
</p>
</div>

<div id="outline-container-orged91158" class="outline-3">
<h3 id="orged91158">Lokale Variablen</h3>
<div class="outline-text-3" id="text-orged91158">
<p>
Wir betrachten hier nur lokale Variablen in Code Blöcken wie z.B.
in Funktionen. Sogenannte Properties die analog definiert werden und
auf top-level Ebene und in Klassen verwendet werden können, haben
erweiterte Möglichkeiten und werden später betrachtet.
</p>

<p>
Das Schlüsselwort <code>var</code> leitet eine Variablendeklaration ein. Wie man
es erwartet ist der Wert einer solchen Variable änderbar. In den
folgenden Beispielen verwenden wir den Typ <code>Int</code>, der erwartungsgemäß
Integer Zahlen repräsentiert.
</p>
<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #a020f0;">fun</span> <span style="color: #0000ff;">main</span>() {
  <span style="color: #a020f0;">var</span> <span style="color: #a0522d;">a</span>: <span style="color: #228b22;">Int</span> = 1    <span style="color: #b22222;">// </span><span style="color: #b22222;">Deklaration mit Typangabe und Initialisierung</span>
  <span style="color: #a020f0;">var</span> <span style="color: #a0522d;">b</span> = 2         <span style="color: #b22222;">// </span><span style="color: #b22222;">Typ Inferenz </span>
  <span style="color: #a020f0;">var</span> <span style="color: #a0522d;">c</span>: <span style="color: #228b22;">Int</span>        <span style="color: #b22222;">// </span><span style="color: #b22222;">Deklaration ohne Initialisierung</span>
  c = 3             <span style="color: #b22222;">// </span><span style="color: #b22222;">sp&#228;tere Initialisierung</span>
  println(<span style="color: #8b2252;">"a = ${</span>a<span style="color: #8b2252;">}, b = ${</span>b<span style="color: #8b2252;">}, c = ${</span>c<span style="color: #8b2252;">}"</span>) 
  a++
  b++
  c++
  println(<span style="color: #8b2252;">"a = ${</span>a<span style="color: #8b2252;">}, b = ${</span>b<span style="color: #8b2252;">}, c = ${</span>c<span style="color: #8b2252;">}"</span>)
}

main()
</pre>
</div>

<pre class="example">
a = 1, b = 2, c = 3
a = 2, b = 3, c = 4
</pre>


<p>
Zunächst muss man festhalten, dass in Kotlin die Typen mit einem
Doppelpunkt abgetrennt nach den Bezeichnern stehen. Das gilt dann auch
für Rückgabewerte von Funktionen, wie wir später sehen werden.
</p>

<p>
Wir sehen zu Beginn der <code>main</code> Funktion die gleichzeitige Deklaration
und Zuweisung der Variablen <code>a</code>, die Deklaration und Initialisierung
der Variablen <code>b</code> ohne Typangabe und die Deklaration der mit Typangabe
der Variable <code>c</code> mit späterer Initialierung der Variablen. 
</p>

<p>
Bei der Variablen <code>b</code> wurde der Typ <code>Int</code> per Typ Inferenz von Kotlin
selber bestimmt, ohne dass der Programmierer dies angeben musste. 
</p>

<p>
Anhand der Nutzung der top-level Funktion <code>println</code> können wir auch
sehen, dass in Kotlin Strings standardmäßig Variablen Interpolation
erlauben.
</p>

<p>
Das Schlüsselwort <code>val</code> leitet eine einmal beschreibbare Variable
ein. Also eher vergleichbar mit einer Konstanten. Es gibt auch noch
das Schlüsselwort <code>const</code>, das im Zusammenspiel mit einer <code>val</code>
Variablen eingesetzt werden kann und eine sofortige Zuweisung
erzwingt, worauf wir aber nicht weiter eingehen, da <code>const</code> recht
inkonsistent nur an wenigen Stellen verwendet werden kann.
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #a020f0;">fun</span> <span style="color: #0000ff;">main</span>() {
  <span style="color: #a020f0;">val</span> <span style="color: #a0522d;">a</span>: <span style="color: #228b22;">Int</span> = 1
  <span style="color: #a020f0;">val</span> <span style="color: #a0522d;">b</span> = 2
  <span style="color: #a020f0;">val</span> <span style="color: #a0522d;">c</span>: <span style="color: #228b22;">Int</span>      <span style="color: #b22222;">// </span><span style="color: #b22222;">Initialisierung kann auch bei val </span><span style="color: #a0522d;">verz&#246;gert</span><span style="color: #b22222;"> sein</span>
  c = 3

  println(<span style="color: #8b2252;">"a = ${</span>a<span style="color: #8b2252;">}, b = ${</span>b<span style="color: #8b2252;">}, c = ${</span>c<span style="color: #8b2252;">}"</span>)
  <span style="color: #b22222;">// </span><span style="color: #b22222;">c = 4           nicht erlaubt, Compiler meldet Fehler!!</span>
}

main()
</pre>
</div>

<pre class="example">
a = 1, b = 2, c = 3
</pre>
</div>
</div>


<div id="outline-container-org5988f0d" class="outline-3">
<h3 id="org5988f0d">Elementare Datentypen</h3>
<div class="outline-text-3" id="text-org5988f0d">
<p>
Anders als in Java werden in Kotlin (fast ausnahmslos) nur Objekttypen
verwendet, auch für alle elementaren Datentypen. Als Konsequenz sind
alle Operationen auf den Datentypen per Member-Funktion erreichbar,
wobei die Operationen größtenteils den aus Java bekannten gleichen.
</p>

<p>
Intern verwendet Kotlin aus Performancegründen teilweise die
primitiven Datentypen der Java VM, aber dies ist weitestgehend
unsichtbar für den Programmierer.
</p>
</div>


<div id="outline-container-orgef7c29e" class="outline-4">
<h4 id="orgef7c29e">Ganzzahlige Datentypen</h4>
<div class="outline-text-4" id="text-orgef7c29e">
<p>
Es gibt die von Java bekannten vorzeichenbehafteten Typen (signed integers)
</p>
<ul class="org-ul">
<li>Byte (8 Bit)</li>
<li>Short (16 Bit)</li>
<li>Int (32 Bit)</li>
<li>Long (64 Bit)</li>
</ul>

<div class="note">
<p>
In den neueren Version von Kotlin ist experimenteller Support für
unsigned integers integriert. Wir gehen aber nicht näher darauf ein.
</p>

</div>

<p>
Bei Belegung von Variablen mit Literalen und fehlender Typangabe wählt
Kotlin im Standardfall den Typ <code>Int</code> aus. Falls der Wertebereich aber
nicht ausreichend ist für das Literal wird <code>Long</code> gewählt. Man kann den
Type <code>Long</code> aber auch per Suffic <code>L</code> an dem Zahlenliteral erzwingen.
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #a020f0;">val</span> <span style="color: #a0522d;">byte</span>: <span style="color: #228b22;">Byte</span> = 1 
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">short</span>: <span style="color: #228b22;">Short</span> = 128
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">int</span>: <span style="color: #228b22;">Int</span> = 32768
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">long</span>: <span style="color: #228b22;">Long</span> = 2147483647
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">int1</span> = 10 <span style="color: #b22222;">// </span><span style="color: #b22222;">Int als default hergeleiteter Typ</span>
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">long1</span> = 2147483647 <span style="color: #b22222;">// </span><span style="color: #b22222;">long, da Wertebereich Int &#252;berschreitet</span>
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">long2</span> = 8L <span style="color: #b22222;">// </span><span style="color: #b22222;">per L Suffix wird Long als Typ erzwungen</span>

long2.toString(2) <span style="color: #b22222;">// </span><span style="color: #b22222;">Zahlen sind Objekte, 8 wird als Zahl zur Basis 2 ausgegeben</span>
</pre>
</div>

<pre class="example">
kotlin.String = 1000
</pre>
</div>
</div>

<div id="outline-container-org1d88be0" class="outline-4">
<h4 id="org1d88be0">Gleitkommazahlen Datentypen</h4>
<div class="outline-text-4" id="text-org1d88be0">
<p>
Analog zum vorherigen Abschnitt gibt es auch bei den Gleitkommazahlen
die beiden von Java bekannten Typen <code>Float</code> und <code>Double</code>.
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #a020f0;">val</span> <span style="color: #a0522d;">double</span> : <span style="color: #228b22;">Double</span> = 0.8
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">pi</span> = 3.14
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">pif</span> = 6.28f <span style="color: #b22222;">// </span><span style="color: #b22222;">Suffix f f&#252;hrt zu Float Type anstatt zum default von Double</span>
println(<span style="color: #8b2252;">"${</span>pi.hashCode()<span style="color: #8b2252;">} ${</span>pif.hashCode()<span style="color: #8b2252;">}"</span>)
</pre>
</div>

<pre class="example">
300063655 1086911939
</pre>
</div>
</div>

<div id="outline-container-org57a6cd8" class="outline-4">
<h4 id="org57a6cd8">Booleans</h4>
<div class="outline-text-4" id="text-org57a6cd8">
<p>
Auch hier gibt es keine großen Überraschungen.
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #a020f0;">val</span> <span style="color: #a0522d;">myTrue</span>: <span style="color: #228b22;">Boolean</span> = <span style="color: #008b8b;">true</span>
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">myFalse</span>: <span style="color: #228b22;">Boolean</span> = <span style="color: #008b8b;">false</span>

println(myTrue || myFalse)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc2fa040" class="outline-4">
<h4 id="orgc2fa040">Zeichen/Characters</h4>
<div class="outline-text-4" id="text-orgc2fa040">
<p>
Hier gibt es ebenfalls keine Überraschungen im Vergleich zu Java.
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #a020f0;">val</span> <span style="color: #a0522d;">charA</span>: <span style="color: #228b22;">Char</span> = <span style="color: #8b2252;">'a'</span>
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">charSpecial</span> = <span style="color: #8b2252;">'\n'</span>
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">charB</span>: <span style="color: #228b22;">Char</span> = <span style="color: #8b2252;">'b'</span>
println(<span style="color: #8b2252;">"${</span>charA<span style="color: #8b2252;">} ${</span>charSpecial<span style="color: #8b2252;">} ${</span>charB<span style="color: #8b2252;">}"</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf968a2a" class="outline-4">
<h4 id="orgf968a2a">Zeichenketten/Strings</h4>
<div class="outline-text-4" id="text-orgf968a2a">
<p>
Strings sind wiederum sehr ähnlich zu Java aufgebaut. Es gibt
zusätzlich zu den normalen Strings auch die sogenannten Raw Strings,
die mehrzeilig sein können und keine Escape Sequenzen umsetzen.
</p>
<div class="note">
<p>
Die in Java 13 eingeführten Raw Strings unterscheiden sich relativ
stark der Kotlin Variante: Interpretatio von Escape Sequenzen und
automatische Behandlung von Einrückungen.
</p>

</div>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #a020f0;">val</span> <span style="color: #a0522d;">rawString</span> = <span style="color: #8b2252;">"""</span>
<span style="color: #8b2252;">    \n\n\t</span>

<span style="color: #8b2252;">    ein Test</span>
<span style="color: #8b2252;">"""</span>.trimIndent()

println(rawString)

println(<span style="color: #8b2252;">"\n\n"</span>)

<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">withoutMargin1</span> = <span style="color: #8b2252;">"""ABC</span>
<span style="color: #8b2252;">                |123</span>
<span style="color: #8b2252;">                |456"""</span>.trimMargin()

println(withoutMargin1)
</pre>
</div>

<pre class="example">
\n\n\t

ein Test



ABC
123
456
</pre>


<p>
Die Funktionen <code>trimIndent()</code> und <code>trimMargin()</code> entfernen die
Einrückungen der inneren Zeilen samt Löschen der ersten und letzten
Zeile.
</p>

<p>
In normalen wie auch in Raw Strings wird String Interpolation
unterstützt.
</p>
<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #a020f0;">val</span> <span style="color: #a0522d;">s</span> = <span style="color: #8b2252;">"2 + 3 = ${</span>2+3<span style="color: #8b2252;">}"</span>
println(s)
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">sr</span> = <span style="color: #8b2252;">"""</span>
<span style="color: #8b2252;">2${'$'} + 3${'$'} = ${</span>2+3<span style="color: #8b2252;">}${'$'}</span>

<span style="color: #8b2252;">4${'$'} + 5${'$'} = ${</span>4+5<span style="color: #8b2252;">}${'$'}</span>
<span style="color: #8b2252;">"""</span>
println(sr)
</pre>
</div>

<pre class="example">
2 + 3 = 5

2$ + 3$ = 5$

4$ + 5$ = 9$
</pre>
</div>
</div>

<div id="outline-container-org484567e" class="outline-4">
<h4 id="org484567e">Arrays</h4>
<div class="outline-text-4" id="text-org484567e">
<p>
Zur Darstellung von Arrays wird die generische Klasse <code>Array</code>
verwendet. Diese Klasse bietet auch eine Vielzahl nützlicher Member
Funktionen an (Sortierung, Suche, Slicing, &#x2026;). Analog wie bei Java
kann die Länge eines Arrays nicht verändert werden. 
</p>

<p>
Zum Erzeugen von Arrays gibt die beiden Wege über die <code>arrayOf()</code>
Funktion und über einen Konstruktor der <code>Array</code> Klasse:
</p>
<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #a020f0;">val</span> <span style="color: #a0522d;">stringArray</span> : <span style="color: #228b22;">Array&lt;String&gt;</span> = arrayOf(<span style="color: #8b2252;">"1"</span>,<span style="color: #8b2252;">"2"</span>)
println(<span style="color: #8b2252;">"L&#228;nge: ${</span>stringArray.size<span style="color: #8b2252;">}"</span>)
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">stringArray2</span> = <span style="color: #228b22;">Array</span>(4){ i -&gt; i.toString()}
stringArray2[2]
</pre>
</div>

<pre class="example">
Länge: 2
kotlin.String = 2
</pre>


<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #a020f0;">fun</span> <span style="color: #0000ff;">arrayTest</span>() : <span style="color: #228b22;">Unit</span> {
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">stringArray</span> : <span style="color: #228b22;">Array&lt;String&gt;</span> = arrayOf(<span style="color: #8b2252;">"1"</span>, <span style="color: #8b2252;">"2"</span>)
println(<span style="color: #8b2252;">"Zugriff &#252;ber eckige Klammern Operator: ${</span>stringArray[0] == <span style="color: #8b2252;">"1"}"</span>)
stringArray.sort()
<span style="color: #b22222;">// </span><span style="color: #b22222;">Arrays haben eine feste L&#228;nge, so dass bei einigen Funktionen auf Arrays neue Arrays erzeugt werden:</span>
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">stringArray2</span> = stringArray.plus(<span style="color: #8b2252;">"3"</span>)
<span style="color: #b22222;">// </span><span style="color: #b22222;">=== ermittelt die Objektidentit&#228;t, == die strukturelle Identit&#228;t</span>
println(<span style="color: #8b2252;">"Sind die Arrays identisch: ${</span>stringArray === stringArray2<span style="color: #8b2252;">}"</span>)
<span style="color: #b22222;">// </span><span style="color: #b22222;">== entspricht dem Vergleich mit der equals() Member Funktion</span>
println(<span style="color: #8b2252;">"Sind die Arrays gleich: ${</span>stringArray == arrayOf(<span style="color: #8b2252;">"1"</span>,<span style="color: #8b2252;">"2"</span>)<span style="color: #8b2252;">}"</span>)
println(<span style="color: #8b2252;">"Sind die Arrays gleich: ${</span>arrayOf(<span style="color: #8b2252;">"1"</span>,<span style="color: #8b2252;">"2"</span>).contentDeepEquals(stringArray)<span style="color: #8b2252;">}"</span>)
stringArray.forEach { s -&gt; print(s) }
println()
println(<span style="color: #8b2252;">"----------"</span>)
stringArray2.forEach { s -&gt; print(s) }
println()
println(<span style="color: #8b2252;">"Arrays schneiden: ${</span>stringArray2.sliceArray(0..1).contentDeepEquals(stringArray)<span style="color: #8b2252;">}"</span>)
}
arrayTest()
</pre>
</div>

<p>
Zusätzlich gibt es noch die Möglichkeit Arrays von primitiven Typen zu nutzen.
Der wichtigste Grund für deren Verwendung ist, dass zur Laufzeit Speicherplatz
gespart wird, da die Inhalte dieser Arrays aus primitiven Typen gebildet werden.
Diese Arrays sind nicht von der Klasse <code>Array</code> in irgendeiner Form abgeleitet,
besitzen aber ähnlichen Funktionsumfang.
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #a020f0;">val</span> <span style="color: #a0522d;">intarray</span> : <span style="color: #228b22;">IntArray</span> = intArrayOf(1,2,3)
intarray.forEach{ ia -&gt; println(ia) }
println()
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">doublearray</span> : <span style="color: #228b22;">DoubleArray</span> = doubleArrayOf(1.0, 2.0, 3.0)
doublearray.forEach{ da -&gt; println(da) }
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgde02234" class="outline-3">
<h3 id="orgde02234">Ausdrücke und Anweisungen</h3>
<div class="outline-text-3" id="text-orgde02234">
<p>
Da Kotlin sich viele Anleihen aus dem Bereich der funktionalen
Programmierung genommen, sind anders als in Java angepasste Varianten
von Anweisungen auch in Form von Ausdrücken verwendbar.
</p>

<div class="note">
<p>
Anmerkung: Ausdrücke liefern Werte - Anweisungen nicht, sie
ändern nur den Kontrollfluss.
</p>

</div>
</div>
</div>
</div>

<div id="outline-container-org77d0243" class="outline-2">
<h2 id="org77d0243">Grundkonstruktion von Programmen</h2>
<div class="outline-text-2" id="text-org77d0243">
</div>
<div id="outline-container-orgfd21f64" class="outline-3">
<h3 id="orgfd21f64">Kein static Modifier und die Folgen</h3>
<div class="outline-text-3" id="text-orgfd21f64">
<p>
Kotlin unterstützt auf Sprachenebene nicht den Modifier <code>static</code>, der
in Java zur Zuordnung von Variablen und Methoden zu Klassen genutzt
werden kann. Dies hat für einige Konstrukte in Kotlin gesorgt, um
Funktionalitäten nachzubilden, für die in Java <code>static</code> verwendet
wurde. Die Details dieser Konstrukte sehen wir uns später an.
</p>

<ul class="org-ul">
<li>Statt static Member Variablen gibt es top-level Properties.</li>
<li>Statt static Methoden gibt es top-level Funktionsdefinitionen.</li>
<li>Für Singletons gibt es die Möglichkeit top-level Quasi-Klassen zu
definieren, von denen genau ein Objekt existiert. Dieses Konstrukt
wird auch einfach Object genannt.</li>
<li>Um Objekten einer Klasse die Möglichkeit zu geben, um auf
Klassenebene Strukturen und Funktionen zu nutzen, gibt es das
Konstrukt <code>companion object</code>, das in einer Klasse definiert sein
kann. Darüber kann man zum Beispiel ein Factory Method Pattern
abbilden. Ein <code>companion object</code> ist also eine Art Singleton, das
explizit einer Klasse zugeordnet ist.</li>
</ul>
</div>
</div>

<div id="outline-container-org464f89f" class="outline-3">
<h3 id="org464f89f">Top Level Konstrukte der Programmiersprache</h3>
<div class="outline-text-3" id="text-org464f89f">
</div>
<div id="outline-container-org6e31034" class="outline-4">
<h4 id="org6e31034">Funktionen</h4>
<div class="outline-text-4" id="text-org6e31034">
<p>
Funktionen treten in den Variationen
</p>
<ul class="org-ul">
<li>Top-level Funktion</li>
<li>Lokale Funktion innerhalb einer anderen Funktion (Local Function)</li>
<li>Member Funktion eines Typs (Member Function)</li>
<li>Funktionsliterale (function liberal) sind Lambda Ausdrücke und
anonyme Funktionen</li>
</ul>
<p>
auf.
</p>
</div>

<div id="outline-container-orgdd6c59f" class="outline-5">
<h5 id="orgdd6c59f">Basisfunktionalität</h5>
<div class="outline-text-5" id="text-orgdd6c59f">
<p>
Die Parameter einer Funktion müssen explizit angegebene Typen haben.
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #b22222;">// </span><span style="color: #b22222;">Parameter k&#246;nnen default Werte haben:</span>
<span style="color: #a020f0;">fun</span> <span style="color: #0000ff;">test1</span>(a:<span style="color: #228b22;">Int</span>, b:<span style="color: #228b22;">Int</span> = 4) : <span style="color: #228b22;">Int</span> {
  <span style="color: #a020f0;">return</span> a+b
}
<span style="color: #b22222;">// </span><span style="color: #b22222;">wie &#252;blich</span>
println(test1(1,2))
<span style="color: #b22222;">// </span><span style="color: #b22222;">mit Benennung der Parameter:</span>
println(test1(b = 3, a = 1))
<span style="color: #b22222;">// </span><span style="color: #b22222;">Parameter mit default Werten k&#246;nnen entfallen, so lange </span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">die Zuordnung der Parameter gew&#228;hrleistet ist:</span>
println(test1(1))

<span style="color: #b22222;">// </span><span style="color: #b22222;">Wenn eine Funktion keine R&#252;ckgabe per return t&#228;tigt</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">ist der R&#252;ckgabetyp Unit bzw. muss es sein.</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">&#220;bergabe eines Lambda Ausdrucks an eine Funktion:</span>
<span style="color: #a020f0;">fun</span> <span style="color: #0000ff;">testLambda</span>(foo : <span style="color: #228b22;">Int</span>, la : (<span style="color: #228b22;">Int</span>) -&gt; <span style="color: #228b22;">Unit</span>) : <span style="color: #228b22;">Unit</span> {
  la(foo)
 }
testLambda(45, {<span style="color: #a020f0;">it</span> -&gt; println(<span style="color: #a020f0;">it</span>)})
<span style="color: #b22222;">// </span><span style="color: #b22222;">Wenn eine Funktion nur einen Ausdruck berechnet kann eine Kurzform</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">ohne return Anweisung und geschweiften Klammern verwendet werden:</span>
<span style="color: #a020f0;">fun</span> <span style="color: #0000ff;">shortTest</span>(a: <span style="color: #228b22;">Int</span>, b: <span style="color: #228b22;">Int</span>) : <span style="color: #228b22;">Int</span> = a + b
println(shortTest(20,40))

<span style="color: #b22222;">// </span><span style="color: #b22222;">Variable Anzahl von Parametern werden als Array &#252;bergeben:</span>
<span style="color: #a020f0;">fun</span> <span style="color: #0000ff;">varTest</span>(<span style="color: #a020f0;">vararg</span> ts: <span style="color: #228b22;">Int</span>) : <span style="color: #228b22;">Int</span> {
  <span style="color: #a020f0;">return</span> ts.fold(0,{acc:<span style="color: #228b22;">Int</span>, i:<span style="color: #228b22;">Int</span> -&gt; acc + i})
}
println(varTest(1,2,3))
</pre>
</div>

<pre class="example">
3
4
5
45
60
6
</pre>


<p>
Funktionen können auch Infix Notation nutzen, wenn die Funktion eine
Member Funktion (oder Extension Funktion) ist, nur einen Parameter hat
und dieser nicht <code>vararg</code> ist.
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">FunctionExample</span> (<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">iMem</span> : <span style="color: #228b22;">Int</span>) {
    <span style="color: #a020f0;">infix</span> <span style="color: #a020f0;">fun</span> <span style="color: #0000ff;">ifxFun</span>(param : <span style="color: #228b22;">Int</span>) : <span style="color: #228b22;">Int</span> {
        <span style="color: #a020f0;">return</span> iMem + param;
    }
}

<span style="color: #a020f0;">fun</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #a020f0;">val</span> <span style="color: #a0522d;">funEx</span> = <span style="color: #228b22;">FunctionExample</span>(200)
    println(funEx ifxFun 4)
}
</pre>
</div>

<p>
Funktionen können auch generisch sein:
</p>
<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #a020f0;">fun</span> &lt;<span style="color: #228b22;">T&gt;</span> testToList(item: <span style="color: #228b22;">T</span>): <span style="color: #228b22;">List&lt;T&gt;</span> {
  <span style="color: #a020f0;">return</span> listOf(item)
}
testToList(12)
</pre>
</div>

<pre class="example">
kotlin.collections.List&lt;kotlin.Int&gt; = [12]
</pre>
</div>
</div>

<div id="outline-container-org1347efe" class="outline-5">
<h5 id="org1347efe">Higher Order Functions</h5>
<div class="outline-text-5" id="text-org1347efe">
<p>
Higher Order Functions bekommen Funktionen als Parameter oder geben
eine Funktion zurück. Um dies zu ermöglichen, muss der Typ einer
Funktion angegeben werden können, um z.B. damit den Typ eines
Funktionsparameters festzulegen.
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #a020f0;">fun</span> &lt;<span style="color: #228b22;">T&gt;</span> countDelegate(liste: <span style="color: #228b22;">List&lt;T&gt;</span>, counter: (<span style="color: #228b22;">List&lt;T&gt;</span>) -&gt; <span style="color: #228b22;">Int</span>) : <span style="color: #228b22;">Int</span>{
  <span style="color: #a020f0;">return</span> counter(liste)
}

countDelegate(listOf(1,2,3), <span style="color: #228b22;">List&lt;Int&gt;</span>::size)
</pre>
</div>

<pre class="example">
kotlin.Int = 3
</pre>


<p>
Um Funktionen als Werte für Funktionstypen zu bekommen gibt es
verschiedene Varianten:
</p>
<ul class="org-ul">
<li><p>
Über einen Lambda Ausdruck:
</p>
<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #a020f0;">val</span> <span style="color: #a0522d;">testFun</span>: (<span style="color: #228b22;">Int</span>) -&gt; <span style="color: #228b22;">Unit</span> = { a -&gt; println(<span style="color: #8b2252;">"Testwert: "</span> + a) }
println(::testFun)
testFun(42)
</pre>
</div>

<pre class="example">
val Line_52.testFun: (kotlin.Int) -&gt; kotlin.Unit
Testwert: 42
</pre>

<p>
Alternativ könnte die Lambda Definition auch so aussehen, wobei
Kotlin hier Typinferenz anwendet soweit möglich:
</p>
<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #a020f0;">val</span> <span style="color: #a0522d;">testFun</span> = { a:<span style="color: #228b22;">Int</span> -&gt; println(<span style="color: #8b2252;">"Testwert: "</span> + a) }
</pre>
</div></li>

<li><p>
Über eine anonyme Funktion:
</p>
<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #a020f0;">val</span> <span style="color: #a0522d;">toInt</span>: (<span style="color: #228b22;">String</span>) -&gt; <span style="color: #228b22;">Int</span> = <span style="color: #a020f0;">fun</span>(s: <span style="color: #228b22;">String</span>): <span style="color: #228b22;">Int</span> { <span style="color: #a020f0;">return</span> s.toIntOrNull() ?: 0 }
println(::toInt)
toInt(<span style="color: #8b2252;">"1"</span>)
</pre>
</div>

<pre class="example">
val Line_54.toInt: (kotlin.String) -&gt; kotlin.Int
kotlin.Int = 1
</pre></li>

<li><p>
Über eine Referenz auf eine bestehende Funktionsdefinition:
</p>
<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #a020f0;">fun</span> <span style="color: #0000ff;">apply</span>(c: <span style="color: #228b22;">String</span>, f: (<span style="color: #228b22;">String</span>) -&gt; <span style="color: #228b22;">Int</span>) : <span style="color: #228b22;">Int</span> = f(c)
apply(<span style="color: #8b2252;">"42"</span>,<span style="color: #228b22;">String</span>::toInt)
</pre>
</div>

<pre class="example">
kotlin.Int = 42
</pre>

<p>
Eine Funktionsreferenz kann dabei auf eine top-level Funktion
(::topLevelFunction), Member oder Extension Funktion (String::toInt)
zeigen.
</p></li>

<li><p>
Zudem gibt es noch den etwas esoterischen Fall, dass eine Klasse
einen Funktionstyp implementiert, was bedeutet, dass sie ein
Interface mit einer Funktion implementiert, die dem Funktionstyp
entspricht, wobei die Funktion den Operator <code>()</code> überlädt (Operator
Overloading), der auf die Funktion <code>invoke()</code> abgebildet wird:
</p>
<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">IntTransformer</span>: (<span style="color: #228b22;">Int</span>) -&gt; <span style="color: #228b22;">Int</span> {
  <span style="color: #a020f0;">override</span> <span style="color: #a020f0;">operator</span> <span style="color: #a020f0;">fun</span> <span style="color: #0000ff;">invoke</span>(x: <span style="color: #228b22;">Int</span>): <span style="color: #228b22;">Int</span> = x + 1
}

<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">intFunction</span>: (<span style="color: #228b22;">Int</span>) -&gt; <span style="color: #228b22;">Int</span> = <span style="color: #228b22;">IntTransformer</span>()
intFunction(5)
</pre>
</div>

<pre class="example">
kotlin.Int = 6
</pre></li>
</ul>

<p>
Lambda Ausdrücke und anonyme Funktionen werden als Funktionsliterale
bezeichnet und können direkt als Ausdruck für die Übergabe von
Funktionen verwendet werden.
</p>

<p>
Ein Lamba Ausdruck ist immer in geschweiften Klammen angegeben und
benötigt im Gegensatz zu einer Funktion mit Block kein exlizites
return Statement. Der letzte Wert in der Abarbeitung ist der
Rückgabewert. Die return Anweisung kann aber trotzdem verwendet werden.
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #a020f0;">val</span> <span style="color: #a0522d;">lambda</span> = { a:<span style="color: #228b22;">Int</span>, b:<span style="color: #228b22;">Int</span> -&gt;
        <span style="color: #a020f0;">val</span> <span style="color: #a0522d;">c</span> = a + b
        <span style="color: #a020f0;">val</span> <span style="color: #a0522d;">b</span> = c*2
        b*3
    }
println(lambda(2,3))
<span style="color: #b22222;">// </span><span style="color: #b22222;">Default Parametername in einem Lambda ist it und die</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">Definition des Parameternamens kann dann entfallen:</span>
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">sum</span> = arrayOf(1,2,3).map { <span style="color: #a020f0;">it</span> * 2 }.sum()
println(sum)
<span style="color: #b22222;">// </span><span style="color: #b22222;">ein Lambda kann als letzter Parameter auch nach</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">den Parameterklammern &#252;bergeben werden:</span>
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">foldValue</span> = arrayOf(1,2,3).fold(10){acc, e -&gt; acc * e}
println(foldValue)
</pre>
</div>

<pre class="example">
30
12
60
</pre>


<p>
Anonyme Funktionen unterscheiden sich zu Lambdas folgendermaßen:
</p>
<ul class="org-ul">
<li>Mit einer anonymen Funktion kann man den Typ des Rückgabewertes
angeben, falls nötig.</li>
<li>Eine <code>return</code> Anweisung in einem Lambda springt aus der umgebenden
Funktion zurück, bei einer anonymen Funktion nur aus dieser selber.</li>
</ul>

<p>
Die Closure eines Lambda Ausdrucks, anonymen Funktion, lokalen
Funktion oder Object Ausdrucks umfasst alle aus dem äußeren Scope
zugreifbaren Variablen. Beispiel:
</p>
<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #a020f0;">var</span> <span style="color: #a0522d;">sum</span> = 0
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">changeSum</span> = { sum = sum + 3 }
changeSum()
println(sum)
</pre>
</div>

<pre class="example">
3
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd1364c3" class="outline-4">
<h4 id="orgd1364c3">Properties</h4>
<div class="outline-text-4" id="text-orgd1364c3">
<p>
Top-level Properties unterscheiden sich von den lokalen Variablen
bzw. den Properties in Klassen. Implementierungstechnisch werden
top-level Properties in JVM Klassen eingebettet, die für die Source
jeweiligen Kotlin Source Dateien erzeugt werden. 
</p>

<p>
Ein top-level Property muss immer bei Deklaration initialisiert
werden, da kein Konstruktor wie in einer Klasse die Initialisierung
erledigen kann, bevor der erste Zugriff stattfinden kann. Eine
Initialisierung ist auch dann notwendig, wenn der Typ der Property als
Nullable angegeben ist. Analog bezüglich der Initialisierung zu
top-level Properties verhalten sich auch Properties in Companion
Objects. Auch diese müssen bei Deklaration initialisiert werden.
</p>
</div>
</div>

<div id="outline-container-org7040771" class="outline-4">
<h4 id="org7040771">Interfaces</h4>
</div>

<div id="outline-container-org2b43337" class="outline-4">
<h4 id="org2b43337">Klassen</h4>
<div class="outline-text-4" id="text-org2b43337">
<p>
Klassen können enthalten:
</p>
<ul class="org-ul">
<li>Konstruktoren und Initialisierungsblöcke</li>
<li>Member Funktionen</li>
<li>Properties</li>
<li>Eingebettete Klassen (nested classes) und innere Klassen (inner
classes sind nested classes mit Zugriff auf das äußere Objekt)</li>
<li>Objekt Deklarationen (z.B. um Singletons zu realisieren oder
Companion Objekte)</li>
</ul>
</div>


<div id="outline-container-org58c06fb" class="outline-5">
<h5 id="org58c06fb">Properties in Klassen</h5>
<div class="outline-text-5" id="text-org58c06fb">
<p>
Properties in Klassen sind analog zu definieren wie top-level Properties.
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">Test</span> {
  <span style="color: #a020f0;">var</span> <span style="color: #a0522d;">test</span> : <span style="color: #228b22;">String</span> = <span style="color: #8b2252;">"Variabler Wert"</span>
  <span style="color: #a020f0;">val</span> <span style="color: #a0522d;">rtest</span> = <span style="color: #8b2252;">"ReadOnly Wert mit type inference"</span>
}

<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">t</span> = <span style="color: #228b22;">Test</span>()
t.test + <span style="color: #8b2252;">" "</span> + t.rtest
</pre>
</div>

<pre class="example">
kotlin.String = Variabler Wert ReadOnly Wert mit type inference
</pre>


<p>
Properties in Klassen können analog zu top-level Properties ihre
default-Getter und -Setter überschreiben:
</p>
<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">Test</span> {
  <span style="color: #a020f0;">var</span> <span style="color: #a0522d;">test</span> : <span style="color: #228b22;">Int</span> = 2
  <span style="color: #a020f0;">get</span>() = <span style="color: #a020f0;">field</span> + 1 <span style="color: #b22222;">// </span><span style="color: #b22222;">Nutzung des backing field</span>
  <span style="color: #a020f0;">set</span>(value) {
    <span style="color: #a020f0;">field</span> += value
  }
}
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">t</span> = <span style="color: #228b22;">Test</span>()
t.test = 2 <span style="color: #b22222;">// </span><span style="color: #b22222;">impliziter Call des Setter</span>
t.test     <span style="color: #b22222;">// </span><span style="color: #b22222;">impliziter Call des Getter</span>
</pre>
</div>


<pre class="example">
kotlin.Int = 5
</pre>


<p>
Man kann auch die Sichtbarkeit der Getter und Setter steuern:
</p>
<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">Test</span> {
  <span style="color: #a020f0;">var</span> <span style="color: #a0522d;">test</span> : <span style="color: #228b22;">Int</span> = 2
  <span style="color: #a020f0;">get</span>() = <span style="color: #a020f0;">field</span> + 1 <span style="color: #b22222;">// </span><span style="color: #b22222;">Nutzung des backing field</span>
  <span style="color: #a020f0;">private</span> <span style="color: #a020f0;">set</span> <span style="color: #b22222;">// </span><span style="color: #b22222;">auch ohne Implementierung nur f&#252;r die Sichtbarkeit</span>
}
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">t</span> = <span style="color: #228b22;">Test</span>()
<span style="color: #b22222;">//</span><span style="color: #b22222;">t.test = 2 w&#252;rde jetzt einen Fehler ergeben</span>
t.test     <span style="color: #b22222;">// </span><span style="color: #b22222;">impliziter Call des Getter</span>
</pre>
</div>

<pre class="example">
kotlin.Int = 3
</pre>
</div>
</div>


<div id="outline-container-org778ddc4" class="outline-5">
<h5 id="org778ddc4">Konstruktoren</h5>
<div class="outline-text-5" id="text-org778ddc4">
<p>
Über den sogenannten primary constructor kann man Klassen schön
kompakt formulieren:
</p>
<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">Test</span> (<span style="color: #a020f0;">var</span> <span style="color: #a0522d;">test</span> : <span style="color: #228b22;">Int</span>) { <span style="color: #b22222;">// </span><span style="color: #b22222;">Konstruktor Parameter und Property gleichzeitig definiert</span>
}
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">t</span> = <span style="color: #228b22;">Test</span>(2)
t.test
</pre>
</div>

<pre class="example">
kotlin.Int = 2
</pre>


<p>
Dieses Beispiel maximal länglich aber mit primary constructor wäre so zu formulieren:
</p>
<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">Test</span> <span style="color: #a020f0;">constructor</span>(testparam : <span style="color: #228b22;">Int</span>) {
  <span style="color: #a020f0;">var</span> <span style="color: #a0522d;">test</span> : <span style="color: #228b22;">Int</span> = testparam
}
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">t</span> = <span style="color: #228b22;">Test</span>(2)
t.test
</pre>
</div>

<pre class="example">
kotlin.Int = 2
</pre>


<p>
Ein secondary constructor muss den primary constructor immer aufrufen,
damit der primary constructor bei Objektinitialisierung immer zuerst
ausgeführt wird. Dies muss vor allen wegen initializer Blocks und
Property Wertzuweisung passieren:
</p>
<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">Test</span> <span style="color: #a020f0;">constructor</span>(testparam : <span style="color: #228b22;">Int</span>) {
  <span style="color: #a020f0;">var</span> <span style="color: #a0522d;">test</span> : <span style="color: #228b22;">Int</span> = testparam
  <span style="color: #a020f0;">var</span> <span style="color: #a0522d;">secTest</span> : <span style="color: #228b22;">Int</span> = 4

  <span style="color: #a020f0;">constructor</span> (testparam: <span style="color: #228b22;">Int</span>, secparam : <span style="color: #228b22;">Int</span>) : <span style="color: #a020f0;">this</span>(testparam) {
    secTest = secparam
  }
}
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">t</span> = <span style="color: #228b22;">Test</span>(4,4)
t.test + t.secTest
</pre>
</div>

<pre class="example">
kotlin.Int = 8
</pre>


<p>
Falls kein primary constructor definiert wird, erzeugt Kotlin einen
default primary constructor, welcher auch automatisch bei Aufruf eines
secondary constructors ausgeführt wird:
</p>
<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">Test</span> {
  <span style="color: #a020f0;">var</span> <span style="color: #a0522d;">test</span> : <span style="color: #228b22;">Int</span>
  <span style="color: #a020f0;">init</span> {
    test = 8
  }
  <span style="color: #a020f0;">constructor</span> (testparam : <span style="color: #228b22;">Int</span>) {
    test += testparam
  }
}
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">t</span> = <span style="color: #228b22;">Test</span>(2)
t.test
</pre>
</div>

<pre class="example">
kotlin.Int = 10
</pre>
</div>
</div>

<div id="outline-container-org72d0a54" class="outline-5">
<h5 id="org72d0a54">Vererbung</h5>
<div class="outline-text-5" id="text-org72d0a54">
<p>
Die Entsprechung zur Klasse <code>Object</code> in Java ist in Kotlin Klasse
<code>Any</code>. Wenn explizit keine Superklasse bei der Definition einer Klasse
angegeben ist, erbt diese von <code>Any</code>.
</p>

<p>
Einige Regeln zur Vererbung erläutern wir in dem folgenden Beispiel.
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #b22222;">/**</span>
<span style="color: #b22222;"> * Ohne das Schl&#252;sselwort &lt;code&gt;open&lt;/code&gt; w&#228;re die Klasse</span>
<span style="color: #b22222;"> * nicht ableitbar, d.h. final.</span>
<span style="color: #b22222;"> * Der primary constructor f&#252;hrt das Property value ein.</span>
<span style="color: #b22222;"> */</span>
<span style="color: #a020f0;">open</span> <span style="color: #a020f0;">class</span> <span style="color: #228b22;">ClassExample</span>(<span style="color: #a020f0;">var</span> <span style="color: #a0522d;">value</span> : <span style="color: #228b22;">Int</span>) {
    <span style="color: #b22222;">/**</span>
<span style="color: #b22222;">     * Auch Properties k&#246;nnen &#252;berschrieben werden, sind aber ebenfalls final im Default Fall:</span>
<span style="color: #b22222;">     * Der default Wert kann sich &#228;ndern oder ein &lt;code&gt;val&lt;/code&gt; kann</span>
<span style="color: #b22222;">     * zum &lt;code&gt;var&lt;/code&gt; werden, aber nicht andersherum.</span>
<span style="color: #b22222;">     * Auch die &lt;code&gt;get&lt;/code&gt; und &lt;code&gt;set&lt;/code&gt; Methoden k&#246;nnen</span>
<span style="color: #b22222;">     * beim &#252;berschreiben ge&#228;ndert oder neu eingef&#252;hrt oder weggelassen werden.</span>
<span style="color: #b22222;">     */</span>
    <span style="color: #a020f0;">open</span> <span style="color: #a020f0;">val</span> <span style="color: #a0522d;">propVal</span> : <span style="color: #228b22;">Double</span> = <span style="color: #228b22;">Double.MAX_VALUE</span>

    <span style="color: #b22222;">/**</span>
<span style="color: #b22222;">     * Damit die Member Funktione &#252;berschrieben werden kann, muss auch sie mit &lt;code&gt;open&lt;/code&gt;</span>
<span style="color: #b22222;">     * eingeleitet werden.</span>
<span style="color: #b22222;">     */</span>
    <span style="color: #a020f0;">open</span> <span style="color: #a020f0;">fun</span> <span style="color: #0000ff;">changeValue</span>(changer : <span style="color: #228b22;">Int</span>) {
        value += changer
    }
}

<span style="color: #b22222;">/**</span>
<span style="color: #b22222;"> * Der primary constructor der abgeleiteten Klasse darf das Property value nicht mehr einf&#252;hren,</span>
<span style="color: #b22222;"> * muss es aber initialisieren - daher fehlt die &lt;em&gt;var&lt;/em&gt; Angabe, der Wert wird</span>
<span style="color: #b22222;"> * aber trotzdem initialisiert.</span>
<span style="color: #b22222;"> * Ohne primary constructor m&#252;ssen die secondary constructors f&#252;r die Initialierung</span>
<span style="color: #b22222;"> * von &lt;code&gt;value&lt;/value&gt; sorgen.</span>
<span style="color: #b22222;"> * Wir markieren diese Klasse wiederum mit &lt;code&gt;open&lt;/code&gt; denn ansonsten w&#228;re sie automatisch</span>
<span style="color: #b22222;"> * final.</span>
<span style="color: #b22222;"> */</span>
<span style="color: #a020f0;">open</span> <span style="color: #a020f0;">class</span> <span style="color: #228b22;">DerivedClassExample</span>(valueParam: <span style="color: #228b22;">Int</span>) : <span style="color: #228b22;">ClassExample</span>(valueParam) {
    <span style="color: #a020f0;">val</span> <span style="color: #a0522d;">notChangeAble</span> : <span style="color: #228b22;">Int</span> = valueParam

    <span style="color: #b22222;">/**</span>
<span style="color: #b22222;">     * Wir &#252;berschreiben hier das Property. Wichtig ist noch, dass diese &#196;nderung des Propertys</span>
<span style="color: #b22222;">     * nicht aktiv ist, wenn die Basisklasse initialisiert wird, was vor der abgeleiteten Klasse</span>
<span style="color: #b22222;">     * passiert.</span>
<span style="color: #b22222;">     */</span>
    <span style="color: #a020f0;">override</span> <span style="color: #a020f0;">val</span> <span style="color: #a0522d;">propVal</span>: <span style="color: #228b22;">Double</span>
        <span style="color: #a020f0;">get</span>() = <span style="color: #a020f0;">super</span>.propVal + 4.0

    <span style="color: #b22222;">/**</span>
<span style="color: #b22222;">     * Der secondary constructor ruft den primary auf, da hier ein Aufruf &lt;code&gt;super(valueParam)&lt;/code&gt;</span>
<span style="color: #b22222;">     * nicht erlaubt ist. Das w&#228;re dann der Fall, wenn es in der abgeleiteten Klasse keinen primary</span>
<span style="color: #b22222;">     * constructor geben w&#252;rde - siehe n&#228;chste Klasse.</span>
<span style="color: #b22222;">     */</span>
    <span style="color: #a020f0;">constructor</span>(valueParam: <span style="color: #228b22;">Int</span>, notChanged: <span style="color: #228b22;">Int</span>) : <span style="color: #a020f0;">this</span>(valueParam) {
        value
    }

    <span style="color: #b22222;">/**</span>
<span style="color: #b22222;">     * Wir &#252;berschreiben die Member Funktion &lt;code&gt;changeValue&lt;/code&gt; hier.</span>
<span style="color: #b22222;">     * Ein &#252;berschreibende Member Funktion ist in weiteren abgeleiteten Klassen ebenfalls</span>
<span style="color: #b22222;">     * &#252;berschreibbar, au&#223;er man markiert ist mit &lt;code&gt;final&lt;/code&gt;</span>
<span style="color: #b22222;">     */</span>
    <span style="color: #a020f0;">override</span> <span style="color: #a020f0;">fun</span> <span style="color: #0000ff;">changeValue</span>(changer: <span style="color: #228b22;">Int</span>) {
        <span style="color: #b22222;">// </span><span style="color: #b22222;">nicht notwendigerweise bisheriges Verhalten nutzen:</span>
        <span style="color: #a020f0;">super</span>.changeValue(changer)
        <span style="color: #b22222;">// </span><span style="color: #b22222;">zus&#228;tzliche Aktion:</span>
        value *= changer
    }
}

<span style="color: #b22222;">/**</span>
<span style="color: #b22222;"> * Diese abgeleitete Klasse hat keinen primary constructor und muss daher im secondary die</span>
<span style="color: #b22222;"> * Basisklasse &#252;ber den &lt;coce&gt;super(valueParam)&lt;/code&gt; Aufruf initialisieren.</span>
<span style="color: #b22222;"> * Die Angabe von &lt;code&gt;final&lt;/code&gt; bei der Klasse ist &#252;berfl&#252;ssig, da ohne die Markierung</span>
<span style="color: #b22222;"> * &lt;code&gt;open&lt;/code&gt; die Klasse automatisch final ist.</span>
<span style="color: #b22222;"> */</span>
<span style="color: #a020f0;">final</span> <span style="color: #a020f0;">class</span> <span style="color: #228b22;">SecondDerivedClassExample</span> : <span style="color: #228b22;">ClassExample</span> {
    <span style="color: #a020f0;">constructor</span>(valueParam : <span style="color: #228b22;">Int</span>) : <span style="color: #a020f0;">super</span>(valueParam)
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcb78b13" class="outline-5">
<h5 id="orgcb78b13">Interfaces</h5>
<div class="outline-text-5" id="text-orgcb78b13">
<p>
Interfaces in Kotlin können Member Funktionen deklarieren als auch
implementieren. Im ersten Fall ist die Funktion dann abstrakt markiert
und in allen Fällen sind die Funktionen überschreibbar.
</p>

<p>
Interfaces können aber im Gegensatz zu abstrakten Klassen keinen
Zustand speichern. Es können aber Properties definiert sein, die im
Interface selber maximal Konstanten abbilden oder generell abstrakt
sind und in den implementierenden Klassen dann überschrieben werden.
</p>

<p>
Ein Beispiel für die Nutzung von Interfaces ist unten angegeben:
</p>
<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #a020f0;">interface</span> <span style="color: #228b22;">InterfaceExample</span> {
    <span style="color: #b22222;">/**</span>
<span style="color: #b22222;">     * Dieses Property ist abstrakt.</span>
<span style="color: #b22222;">     */</span>
    <span style="color: #a020f0;">val</span> <span style="color: #a0522d;">firstProp</span> : <span style="color: #228b22;">Int</span>

    <span style="color: #a020f0;">val</span> <span style="color: #a0522d;">secondProp</span> : <span style="color: #228b22;">Int</span>
    <span style="color: #a020f0;">get</span>() = 42

    <span style="color: #b22222;">/**</span>
<span style="color: #b22222;">     * Diese Funktion ist abstrakt.</span>
<span style="color: #b22222;">     */</span>
    <span style="color: #a020f0;">fun</span> <span style="color: #0000ff;">firstInterfaceFunction</span>(param1 : <span style="color: #228b22;">Double</span>) : <span style="color: #228b22;">Int</span>

    <span style="color: #b22222;">/**</span>
<span style="color: #b22222;">     * Diese Funktion</span>
<span style="color: #b22222;">     */</span>
    <span style="color: #a020f0;">fun</span> <span style="color: #0000ff;">secondInterfaceFunction</span>(param1 : <span style="color: #228b22;">Int</span>, param2 : <span style="color: #228b22;">Double</span>) : <span style="color: #228b22;">Int</span> {
        <span style="color: #a020f0;">return</span> param1 * firstInterfaceFunction(param2)
    }
}

<span style="color: #b22222;">/**</span>
<span style="color: #b22222;"> * Wir &#252;berschreiben das erste Property mit dem primary constructor</span>
<span style="color: #b22222;"> * das erste Property des Interfaces.</span>
<span style="color: #b22222;"> */</span>
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">ImplementInterface</span>(<span style="color: #a020f0;">override</span> <span style="color: #a020f0;">val</span> <span style="color: #a0522d;">firstProp</span> : <span style="color: #228b22;">Int</span> = 55) : <span style="color: #228b22;">InterfaceExample</span> {

    <span style="color: #a020f0;">override</span> <span style="color: #a020f0;">val</span> <span style="color: #a0522d;">secondProp</span>: <span style="color: #228b22;">Int</span>
        <span style="color: #a020f0;">get</span>() = <span style="color: #a020f0;">super</span>.secondProp + firstProp

    <span style="color: #b22222;">/**</span>
<span style="color: #b22222;">     * Wir &#252;berschreiben die abstrakte Funktion.</span>
<span style="color: #b22222;">     */</span>
    <span style="color: #a020f0;">override</span> <span style="color: #a020f0;">fun</span> <span style="color: #0000ff;">firstInterfaceFunction</span>(param1: <span style="color: #228b22;">Double</span>): <span style="color: #228b22;">Int</span> {
        <span style="color: #a020f0;">return</span> param1.toInt()
    }

    <span style="color: #b22222;">/**</span>
<span style="color: #b22222;">     * Wir &#252;berschreiben auch nicht notwendigerweise die implementierte Funktion.</span>
<span style="color: #b22222;">     */</span>
    <span style="color: #a020f0;">override</span> <span style="color: #a020f0;">fun</span> <span style="color: #0000ff;">secondInterfaceFunction</span>(param1: <span style="color: #228b22;">Int</span>, param2: <span style="color: #228b22;">Double</span>): <span style="color: #228b22;">Int</span> {
        <span style="color: #a020f0;">return</span> <span style="color: #a020f0;">super</span>.secondInterfaceFunction(param1, param2) + 2
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc123311" class="outline-5">
<h5 id="orgc123311">Extensions</h5>
<div class="outline-text-5" id="text-orgc123311">
<p>
Kotlin bietet auch die Möglichkeit zu Klassen Memberfunktionen
hinzuzufügen, obwohl diese Klassen eigentlich nicht änderbar sind, da
sie zum Beispiel aus einer von extern eingebundenen Bibliothek
stammen. Analog lassen sich auch Properties hinzufügen, wobei hier
aber kein separater Zustand (also ein <code>backing field</code> dazu fehlt)
speicherbar ist und der Wert des Properties entweder konstant oder
errechnet ist.
</p>

<p>
Beispiele sind unten angegeben:
</p>
<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #b22222;">/**</span>
<span style="color: #b22222;"> * Wir werden diese Klasse per Extensions erweitern (auch wenn wir die Klasse</span>
<span style="color: #b22222;"> * hier direkt im Zugriff haben und nicht auf diesen Mechanismus angewiesen w&#228;ren.</span>
<span style="color: #b22222;"> */</span>
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">ExtensionExample</span>(<span style="color: #a020f0;">var</span> <span style="color: #a0522d;">memberVar</span> : <span style="color: #228b22;">Int</span> = 4) {
}

<span style="color: #b22222;">/**</span>
<span style="color: #b22222;"> * Erweiterung um diese Funktion.</span>
<span style="color: #b22222;"> */</span>
<span style="color: #a020f0;">fun</span> <span style="color: #228b22;">ExtensionExample.extendFun</span>() {
    <span style="color: #a020f0;">this</span>.memberVar = 5
}

<span style="color: #b22222;">/**</span>
<span style="color: #b22222;"> * Erweiterung um dieses Property</span>
<span style="color: #b22222;"> */</span>
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">ExtensionExample</span><span style="color: #228b22;">.extMemberVar</span> : <span style="color: #228b22;">Double</span>
<span style="color: #a020f0;">get</span>() = 4.5

<span style="color: #a020f0;">fun</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #a020f0;">val</span> <span style="color: #a0522d;">ext</span> = <span style="color: #228b22;">ExtensionExample</span>()
    println(ext.extMemberVar)
    println(ext.extendFun())
}
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org7d00225" class="outline-3">
<h3 id="org7d00225">Organisation von Source Code</h3>
<div class="outline-text-3" id="text-org7d00225">
<p>
In diesem Abschnitt beschäftigen wir uns mit der Frage, wie man die
zuvor erwähnten top-level Sprachkonstrukte organisiert, um eine
strukturierte Programmentwicklung zu ermöglichen.
</p>
</div>

<div id="outline-container-orgd94a6a8" class="outline-4">
<h4 id="orgd94a6a8">Modularisierung</h4>
<div class="outline-text-4" id="text-orgd94a6a8">
<p>
Bisher haben wir in den Beispielen keine Konstrukte zur
Modularisierung von Code verwendet. Kotlin hat hierbei diese
Möglichkeiten:
</p>
<ul class="org-ul">
<li>Package</li>
<li>Module</li>
</ul>

<p>
Modules spielen eine Rolle bei der Sichtbarkeit von <code>internal</code>
Deklarationen und ansonsten bei einigen Backends für den Kotlin
Code. Wir werden dieses Konstrukt daher nicht weiter betrachten.
</p>
</div>
</div>


<div id="outline-container-org4965a55" class="outline-4">
<h4 id="org4965a55">Aufbau einer Source Code Datei</h4>
</div>

<div id="outline-container-org111a383" class="outline-4">
<h4 id="org111a383">Organisation der Dateiablage</h4>
</div>

<div id="outline-container-orgcb8bac2" class="outline-4">
<h4 id="orgcb8bac2">Sichtbarkeitsregeln</h4>
</div>
</div>
</div>

<div id="outline-container-orgeca5528" class="outline-2">
<h2 id="orgeca5528">Erstellen einer Domain Specific Language</h2>
<div class="outline-text-2" id="text-orgeca5528">
<p>
Einige Sprachfeatures von Kotlin wurden im Hinblick auf die Erstellung
von Domain Specific Languages eingeführt bzw. optimiert. Dazu zählen:
</p>
<ul class="org-ul">
<li>Function type with receiver: Hiermit können Funktionsliterale
erzeugt werden, die Objekte eines in der Signatur der Funktion
angegebenen Typs als <code>this</code> Referenz in der Implementierung der
Funktion nutzen können. D.h. die Funktion hat die Möglichkeiten wie
eine Member Funktion des Typs, ohne aber Teil der Typdefinition zu
sein, da sie ein Funktionsliteral ist.</li>
<li>Ein Lambda Ausdruck als letzter Parameter einer Funktion kann
außerhalb der runden Klammern der Parameterliste übergeben
werden. Der Lamba Ausdruck sieht dann so aus, als würde er als Block
zum Funktionsaufruf gehören, wird aber in der eigentlichen Funktion
verwendet.</li>
<li>Funktionen, die in Infix Notation aufgerufen werden können.</li>
<li>Die Möglichkeit Operatoren zu überladen (Operator Overloading).</li>
<li>Die Möglichkeit Funktionen mit benannten Parameter aufzurufen.</li>
</ul>


<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">DslTestbed</span> {
    <span style="color: #a020f0;">class</span> <span style="color: #228b22;">Outer</span> {
        <span style="color: #a020f0;">var</span> <span style="color: #a0522d;">innerNodes</span> = mutableListOf&lt;<span style="color: #228b22;">Inner&gt;</span>()

        <span style="color: #a020f0;">fun</span> <span style="color: #a020f0;">inner</span>(<span style="color: #a020f0;">init</span>: <span style="color: #228b22;">Inner.</span>() -&gt; <span style="color: #228b22;">Unit</span>){
            <span style="color: #a020f0;">val</span> <span style="color: #a0522d;">child</span> = <span style="color: #228b22;">Inner</span>()
            child.<span style="color: #a020f0;">init</span>()
            innerNodes.add(child)
        }

        <span style="color: #a020f0;">fun</span> <span style="color: #0000ff;">show</span>() : <span style="color: #228b22;">String</span> {
            <span style="color: #a020f0;">val</span> <span style="color: #a0522d;">lines</span> = mutableListOf&lt;<span style="color: #228b22;">String&gt;</span>()
            lines.add(<span style="color: #8b2252;">"Outer node"</span>)
            innerNodes.forEach(){
                lines.add(<span style="color: #a020f0;">it</span>.show())
            }
            <span style="color: #a020f0;">return</span> lines.joinToString(separator = <span style="color: #8b2252;">"\n"</span>)
        }
    }

    <span style="color: #a020f0;">class</span> <span style="color: #228b22;">Inner</span>() {
        <span style="color: #a020f0;">val</span> <span style="color: #a0522d;">innerNodes</span> = mutableListOf&lt;<span style="color: #228b22;">InnerMost&gt;</span>()

        <span style="color: #a020f0;">fun</span> <span style="color: #0000ff;">innerMost</span>(weight: <span style="color: #228b22;">Double</span>){
            <span style="color: #a020f0;">val</span> <span style="color: #a0522d;">child</span> = <span style="color: #228b22;">InnerMost</span>(weight)
            innerNodes.add(child)
        }

        <span style="color: #a020f0;">fun</span> <span style="color: #0000ff;">show</span>() : <span style="color: #228b22;">String</span> {
            <span style="color: #a020f0;">val</span> <span style="color: #a0522d;">lines</span> = mutableListOf&lt;<span style="color: #228b22;">String&gt;</span>()
            lines.add(<span style="color: #8b2252;">"Inner node: "</span>.prependIndent(<span style="color: #8b2252;">"  "</span>))
            innerNodes.forEach(){
                lines.add(<span style="color: #a020f0;">it</span>.show())
            }
            <span style="color: #a020f0;">return</span> lines.joinToString(separator = <span style="color: #8b2252;">"\n"</span>)
        }
    }

    <span style="color: #a020f0;">class</span> <span style="color: #228b22;">InnerMost</span>(<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">weight</span>: <span style="color: #228b22;">Double</span>) {
        <span style="color: #a020f0;">fun</span> <span style="color: #0000ff;">show</span>() : <span style="color: #228b22;">String</span> {
            <span style="color: #a020f0;">return</span> <span style="color: #8b2252;">"InnerMost node: "</span>.prependIndent(<span style="color: #8b2252;">"    "</span>) + <span style="color: #228b22;">String.format</span>(<span style="color: #8b2252;">"%+07.2g"</span>,weight)
        }
    }

    <span style="color: #a020f0;">companion</span> <span style="color: #a020f0;">object</span> {
        <span style="color: #a020f0;">fun</span> <span style="color: #0000ff;">outer</span>(<span style="color: #a020f0;">init</span>: <span style="color: #228b22;">Outer.</span>() -&gt; <span style="color: #228b22;">Unit</span>) : <span style="color: #228b22;">String</span> {
            <span style="color: #a020f0;">val</span> <span style="color: #a0522d;">outer</span> = <span style="color: #228b22;">Outer</span>()
            outer.<span style="color: #a020f0;">init</span>()
            <span style="color: #a020f0;">return</span> outer.show()
        }
    }
}

<span style="color: #a020f0;">fun</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #a020f0;">val</span> <span style="color: #a0522d;">structure</span> =
        <span style="color: #228b22;">DslTestbed.outer</span> {
            <span style="color: #a020f0;">inner</span> {
                innerMost(weight = 45.8889)
                innerMost(weight = -1938.4883)
            }
            <span style="color: #a020f0;">inner</span> {
                innerMost(weight = 22.0048)
                innerMost(weight = 234234.23423)
            }
        }
    println(structure)
}
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Autor: Reinhard Braumandl</p>
<p class="date">Created: 2021-04-18 So 16:25</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
